// File: pkg/generator/python/generator.go

package python

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/strongcodr/lowcodefusion/pkg/fetcher"
)

// Operation represents a single integration operation
type Operation struct {
	Name        string
	Parameters  []Parameter
	ReturnType  string
	Description string
	ModulePath  string // Path to the module (e.g., "AWS.ec2")
	FilePath    string // Path to the original JSON file
}

// Parameter represents an input to an operation
type Parameter struct {
	Name        string
	Type        string
	Required    bool
	Description string
}

// FlowFile represents the JSON structure of a flow file
type FlowFile struct {
	Name      string    `json:"name"`
	Processes []Process `json:"processes"`
	Meta      FlowMeta  `json:"meta"`
}

// Process represents a process within a flow
type Process struct {
	Name      string     `json:"name"`
	Variables []Variable `json:"variables"`
}

// Variable represents a variable within a process
type Variable struct {
	Name     string       `json:"name"`
	IsInput  bool         `json:"isInput"`
	IsOutput bool         `json:"isOutput"`
	Required bool         `json:"required"`
	Meta     VariableMeta `json:"meta"`
	Type     interface{}  `json:"type"`
}

// VariableMeta contains metadata for a variable
type VariableMeta struct {
	Description string `json:"description"`
}

// FlowMeta contains metadata for a flow
type FlowMeta struct {
	Info string `json:"info"`
}

// TypeDefinition represents a complex type definition
type TypeDefinition struct {
	Name          string
	PythonType    string
	Description   string
	FilePath      string // Path to the file that defines this type
	ModulePath    string // Module path where this type is used (e.g., "AWS.ec2")
	OperationName string // Name of the operation that uses this type (e.g., "RunInstances")
}

// TypeRegistry tracks and manages complex type definitions
type TypeRegistry struct {
	Types map[string]TypeDefinition
	Dir   string
}

// NewTypeRegistry creates a new TypeRegistry
func NewTypeRegistry(dir string) *TypeRegistry {
	return &TypeRegistry{
		Types: make(map[string]TypeDefinition),
		Dir:   dir,
	}
}

// RegisterType adds a type to the registry
func (tr *TypeRegistry) RegisterType(
	name string,
	pythonType string,
	description string,
	filePath string,
	modulePath string,
	operationName string,
) TypeDefinition {
	// Normalize the type name
	normalizedName := sanitizeName(name)

	// Check if the type is already registered
	if existing, exists := tr.Types[normalizedName]; exists {
		return existing
	}

	// Create a new type definition
	typeDef := TypeDefinition{
		Name:          normalizedName,
		PythonType:    pythonType,
		Description:   description,
		FilePath:      filePath,
		ModulePath:    modulePath,
		OperationName: operationName,
	}

	// Add to the registry
	tr.Types[normalizedName] = typeDef

	return typeDef
}

// WriteTypesFiles generates Python modules with type definitions organized by operation
func (tr *TypeRegistry) WriteTypesFiles(outDir string) error {
	if len(tr.Types) == 0 {
		return nil // No types to write
	}

	// Create the types directory with underscore prefix to separate it clearly
	typesDir := filepath.Join(outDir, "_types")
	if err := os.MkdirAll(typesDir, 0755); err != nil {
		return fmt.Errorf("failed to create types directory: %v", err)
	}

	// Create __init__.py file
	if err := createInitFile(typesDir); err != nil {
		return err
	}

	// Group types by module path and operation name
	typesByOperation := make(map[string]map[string][]TypeDefinition)
	for _, typeDef := range tr.Types {
		modulePath := typeDef.ModulePath
		if modulePath == "" {
			modulePath = "common" // Default module for types without a specific module
		}
		
		opName := typeDef.OperationName
		if opName == "" {
			opName = "common" // Default for types without a specific operation
		}
		
		// Ensure map hierarchy exists
		if _, exists := typesByOperation[modulePath]; !exists {
			typesByOperation[modulePath] = make(map[string][]TypeDefinition)
		}
		
		typesByOperation[modulePath][opName] = append(typesByOperation[modulePath][opName], typeDef)
	}

	// Initialize the imports for the main __init__.py
	initImports := "# Generated by LowCodeFusion\n"

	// Process each module
	for modulePath, opTypes := range typesByOperation {
		// Convert module path to directory structure
		// AWS.ec2 -> AWS/ec2
		moduleDir := strings.ReplaceAll(modulePath, ".", string(filepath.Separator))
		moduleTypesDir := filepath.Join(typesDir, moduleDir)

		// Ensure the module directory exists
		if err := os.MkdirAll(moduleTypesDir, 0755); err != nil {
			return fmt.Errorf("failed to create module types directory %s: %v", moduleTypesDir, err)
		}

		// Create __init__.py files along the path
		dirPath := typesDir
		for _, part := range strings.Split(moduleDir, string(filepath.Separator)) {
			dirPath = filepath.Join(dirPath, part)
			if err := createInitFile(dirPath); err != nil {
				return err
			}
		}

		// Initialize module __init__.py imports
		moduleInitImports := "# Generated by LowCodeFusion\n"

		// Process each operation within the module
		for opName, types := range opTypes {
			// Create the types file for this operation
			typesFilePath := filepath.Join(moduleTypesDir, fmt.Sprintf("%s_types.py", opName))

			// Generate file content
			content := "# Generated by LowCodeFusion\n"
			content += "from typing import Any, Dict, List, Optional, Union, TypedDict, Literal\n"
			content += "from datetime import datetime\n\n"

			// Extract JSON schemas and generate rich type definitions
			generatedTypes := make(map[string]bool)
			for _, typeDef := range types {
				// We need to parse the original JSON file to extract detailed schema information
				fileContent, err := os.ReadFile(typeDef.FilePath)
				if err != nil {
					fmt.Printf("Warning: Could not read file %s: %v\n", typeDef.FilePath, err)
					continue
				}

				var flowFile FlowFile
				if err := json.Unmarshal(fileContent, &flowFile); err != nil {
					fmt.Printf("Warning: Could not parse JSON from %s: %v\n", typeDef.FilePath, err)
					continue
				}

				// Process only the first process (should be the main one)
				if len(flowFile.Processes) == 0 {
					continue
				}
				process := flowFile.Processes[0]

				// Find the variable that matches this type
				for _, variable := range process.Variables {
					// Skip variables without types
					if variable.Type == nil {
						continue
					}

					// See if this is a parameter or return type that we're looking for
					isMatch := false
					if strings.HasSuffix(typeDef.Name, "_Result_Type") && variable.IsOutput {
						isMatch = true
					} else if strings.Contains(typeDef.Name, "_"+variable.Name+"_Type") && variable.IsInput {
						isMatch = true
					} else {
						continue
					}

					if !isMatch {
						continue
					}

					// Process the type
					typeObj, ok := variable.Type.(map[string]interface{})
					if !ok {
						continue
					}

					// Extract definitions if they exist
					definitions := make(map[string]interface{})
					if defs, ok := typeObj["definitions"].(map[string]interface{}); ok {
						definitions = defs
					}

					// Parse the schema
					schema := jsonTypeToSchemaType(typeDef.Name, typeObj, definitions)
					schema.IsRoot = true

					// Generate TypedDict classes for all complex types
					if schema.Type == "object" && len(schema.Properties) > 0 {
						// Generate TypedDict for the root object
						typeDictCode := generatePythonTypedDict(schema, generatedTypes)
						content += fmt.Sprintf("# %s\n", typeDef.Description)
						content += fmt.Sprintf("# From: %s\n", typeDef.FilePath)
						content += typeDictCode

						// Mark as generated
						generatedTypes[schema.Name] = true

						// Generate TypedDict classes for all nested definitions
						if schema.Definitions != nil {
							for defName, defSchema := range schema.Definitions {
								if defSchema.Type == "object" && len(defSchema.Properties) > 0 && !generatedTypes[defName] {
									typeDictCode := generatePythonTypedDict(defSchema, generatedTypes)
									content += typeDictCode
									generatedTypes[defName] = true
								}
							}
						}
					} else {
						// For non-object types, use the simplified representation
						content += fmt.Sprintf("# %s\n", typeDef.Description) 
						content += fmt.Sprintf("# From: %s\n", typeDef.FilePath)
						content += fmt.Sprintf("%s = %s\n\n", typeDef.Name, typeDef.PythonType)
					}
				}
			}

			// Write to file
			if err := os.WriteFile(typesFilePath, []byte(content), 0644); err != nil {
				return fmt.Errorf("failed to write types file %s: %v", typesFilePath, err)
			}

			// Add to module __init__.py imports
			moduleInitImports += fmt.Sprintf("from .%s_types import *\n", opName)

			fmt.Printf("- Generated types file: %s\n", typesFilePath)
		}

		// Write module __init__.py
		moduleInitPath := filepath.Join(moduleTypesDir, "__init__.py")
		if err := os.WriteFile(moduleInitPath, []byte(moduleInitImports), 0644); err != nil {
			return fmt.Errorf("failed to write module __init__.py file %s: %v", moduleInitPath, err)
		}

		// Add to main __init__.py imports
		relModulePath := strings.ReplaceAll(moduleDir, string(filepath.Separator), ".")
		initImports += fmt.Sprintf("from .%s import *\n", relModulePath)
	}

	// Write the main __init__.py to import all modules
	mainInitPath := filepath.Join(typesDir, "__init__.py")
	if err := os.WriteFile(mainInitPath, []byte(initImports), 0644); err != nil {
		return fmt.Errorf("failed to write main __init__.py file: %v", err)
	}

	return nil
}

// sanitizeName converts a name to a valid Python identifier
func sanitizeName(name string) string {
	// Replace spaces and other non-alphanumeric characters with underscores
	re := regexp.MustCompile(`[^a-zA-Z0-9_]`)
	return re.ReplaceAllString(name, "_")
}

// SchemaType represents a type extracted from a JSON schema
type SchemaType struct {
	Name        string                 // Name of the type
	Type        string                 // Type (string, integer, object, array, etc.)
	Format      string                 // Format (date-time, etc.)
	Description string                 // Description of the type
	Properties  map[string]SchemaType  // Object properties
	Items       *SchemaType            // Array item type
	Enum        []string               // Enum values
	Ref         string                 // Reference to another type
	Required    []string               // Required properties
	OneOf       []SchemaType           // OneOf variants
	IsRoot      bool                   // Is this a root type (not a nested type)
	Definitions map[string]SchemaType  // Type definitions (for root types)
}

// pathTracker is used to track the JSON schema reference path to detect circular references
type pathTracker struct {
	paths map[string]bool
}

// newPathTracker creates a new pathTracker
func newPathTracker() *pathTracker {
	return &pathTracker{
		paths: make(map[string]bool),
	}
}

// has checks if a path has been visited
func (p *pathTracker) has(path string) bool {
	return p.paths[path]
}

// add marks a path as visited
func (p *pathTracker) add(path string) {
	p.paths[path] = true
}

// remove marks a path as no longer visited
func (p *pathTracker) remove(path string) {
	delete(p.paths, path)
}

// jsonTypeToSchemaType converts a JSON schema object to a SchemaType
func jsonTypeToSchemaType(typeName string, typeInfo interface{}, definitions map[string]interface{}) SchemaType {
	return jsonTypeToSchemaTypeWithTracker(typeName, typeInfo, definitions, newPathTracker())
}

// jsonTypeToSchemaTypeWithTracker converts a JSON schema object to a SchemaType with path tracking to avoid circular references
func jsonTypeToSchemaTypeWithTracker(typeName string, typeInfo interface{}, definitions map[string]interface{}, tracker *pathTracker) SchemaType {
	schemaType := SchemaType{
		Name:       typeName,
		Properties: make(map[string]SchemaType),
	}

	// Handle simple string type
	if typeStr, ok := typeInfo.(string); ok {
		schemaType.Type = typeStr
		return schemaType
	}

	// Handle complex type (object with properties)
	if typeObj, ok := typeInfo.(map[string]interface{}); ok {
		// Get direct type property
		if typeType, ok := typeObj["type"].(string); ok {
			schemaType.Type = typeType
		}

		// Get format if available
		if format, ok := typeObj["format"].(string); ok {
			schemaType.Format = format
		}

		// Get description if available
		if desc, ok := typeObj["description"].(string); ok {
			schemaType.Description = desc
		}

		// Get required properties
		if req, ok := typeObj["required"].([]interface{}); ok {
			for _, r := range req {
				if reqStr, ok := r.(string); ok {
					schemaType.Required = append(schemaType.Required, reqStr)
				}
			}
		}

		// Handle array type
		if schemaType.Type == "array" {
			if items, ok := typeObj["items"].(map[string]interface{}); ok {
				// Check for circular reference
				itemPath := typeName + ".items"
				if !tracker.has(itemPath) {
					tracker.add(itemPath)
					itemType := jsonTypeToSchemaTypeWithTracker(typeName+"Item", items, definitions, tracker)
					schemaType.Items = &itemType
					tracker.remove(itemPath)
				} else {
					// Circular reference detected, use Any for items
					schemaType.Items = &SchemaType{Name: "Any", Type: "any"}
				}
			}
		}

		// Handle object type with properties
		if props, ok := typeObj["properties"].(map[string]interface{}); ok && (schemaType.Type == "object" || schemaType.Type == "") {
			schemaType.Type = "object"
			
			// Process a limited number of properties to avoid stack overflow
			propCount := 0
			for propName, propType := range props {
				// Only process a reasonable number of properties (this is a safety measure)
				if propCount >= 100 {
					break
				}
				
				// Check for circular reference
				propPath := typeName + ".properties." + propName
				if !tracker.has(propPath) {
					tracker.add(propPath)
					schemaType.Properties[propName] = jsonTypeToSchemaTypeWithTracker(propName, propType, definitions, tracker)
					tracker.remove(propPath)
				} else {
					// Circular reference detected, use Any for this property
					schemaType.Properties[propName] = SchemaType{Name: propName, Type: "any"}
				}
				propCount++
			}
		}

		// Handle enum values
		if enumValues, ok := typeObj["enum"].([]interface{}); ok {
			for _, val := range enumValues {
				if strVal, ok := val.(string); ok {
					schemaType.Enum = append(schemaType.Enum, strVal)
				} else if numVal, ok := val.(float64); ok {
					schemaType.Enum = append(schemaType.Enum, fmt.Sprintf("%v", numVal))
				} else if boolVal, ok := val.(bool); ok {
					schemaType.Enum = append(schemaType.Enum, fmt.Sprintf("%v", boolVal))
				}
			}
		}

		// Handle schema reference
		if ref, ok := typeObj["$ref"].(string); ok {
			schemaType.Ref = ref
			// Extract the referenced type name
			parts := strings.Split(ref, "/")
			if len(parts) > 0 {
				refTypeName := parts[len(parts)-1]
				
				// Check for circular reference
				refPath := fmt.Sprintf("$ref:%s", ref)
				if !tracker.has(refPath) && len(parts) > 1 && parts[1] == "definitions" && definitions != nil {
					// If it's a reference to a definition, try to resolve it
					if defType, ok := definitions[refTypeName]; ok {
						tracker.add(refPath)
						// Get the basic type information from the reference, but don't resolve nested references
						refSchema := jsonTypeToSchemaTypeWithTracker(refTypeName, defType, definitions, tracker)
						tracker.remove(refPath)
						
						// Just copy the essential info without deep nesting
						schemaType.Type = refSchema.Type
						schemaType.Format = refSchema.Format
						// Don't copy properties deeply to avoid circular refs
					}
				}
				// We'll just keep the reference name for later use
			}
		}

		// Handle oneOf - limit depth to avoid recursion
		if oneOfList, ok := typeObj["oneOf"].([]interface{}); ok && len(oneOfList) < 10 {
			oneOfPath := typeName + ".oneOf"
			if !tracker.has(oneOfPath) {
				tracker.add(oneOfPath)
				for i, oneOfType := range oneOfList {
					// Limit to 5 oneOf variants to avoid explosion
					if i >= 5 {
						break
					}
					oneOfSchema := jsonTypeToSchemaTypeWithTracker(typeName+"OneOf", oneOfType, definitions, tracker)
					schemaType.OneOf = append(schemaType.OneOf, oneOfSchema)
				}
				tracker.remove(oneOfPath)
			}
		}

		// Handle definitions (only for root types) - with limits
		if defs, ok := typeObj["definitions"].(map[string]interface{}); ok {
			schemaType.Definitions = make(map[string]SchemaType)
			defCount := 0
			
			for defName, defType := range defs {
				// Only process a reasonable number of definitions
				if defCount >= 50 {
					break
				}
				
				// Check for circular reference
				defPath := "definitions." + defName
				if !tracker.has(defPath) {
					tracker.add(defPath)
					schemaType.Definitions[defName] = jsonTypeToSchemaTypeWithTracker(defName, defType, defs, tracker)
					tracker.remove(defPath)
				} else {
					// Just create a placeholder for circular references
					schemaType.Definitions[defName] = SchemaType{Name: defName, Type: "any"}
				}
				defCount++
			}
		}
	}

	return schemaType
}

// schemaTypeToPythonType converts a SchemaType to a Python type string
func schemaTypeToPythonType(schema SchemaType, rootTypes map[string]bool) string {
	// Handle references first - they override the type
	if schema.Ref != "" {
		// Extract the referenced type name
		parts := strings.Split(schema.Ref, "/")
		if len(parts) > 0 {
			refTypeName := parts[len(parts)-1]
			return sanitizeName(refTypeName)
		}
	}

	// Handle different types
	switch schema.Type {
	case "string":
		// Handle string with enum values
		if len(schema.Enum) > 0 {
			// Use Literal["val1", "val2", ...] syntax
			enumValues := make([]string, 0, len(schema.Enum))
			for _, val := range schema.Enum {
				enumValues = append(enumValues, fmt.Sprintf("%q", val))
			}
			return fmt.Sprintf("Literal[%s]", strings.Join(enumValues, ", "))
		}
		if schema.Format == "date-time" {
			return "datetime"
		}
		return "str"
	case "integer", "number":
		return "int"
	case "boolean":
		return "bool"
	case "array":
		if schema.Items != nil {
			itemType := schemaTypeToPythonType(*schema.Items, rootTypes)
			return fmt.Sprintf("List[%s]", itemType)
		}
		return "List[Any]"
	case "object":
		// If this is a root type, it should have a registered TypedDict
		if rootTypes[schema.Name] {
			return schema.Name
		}
		return "Dict[str, Any]"
	default:
		// For oneOf, try to build a Union type
		if len(schema.OneOf) > 0 {
			types := make([]string, 0, len(schema.OneOf))
			for _, oneOfType := range schema.OneOf {
				types = append(types, schemaTypeToPythonType(oneOfType, rootTypes))
			}
			return fmt.Sprintf("Union[%s]", strings.Join(types, ", "))
		}
		return "Any"
	}
}

// generatePythonTypedDict generates Python TypedDict code for a SchemaType
func generatePythonTypedDict(schema SchemaType, rootTypes map[string]bool) string {
	result := ""
	
	// Generate docstring if description exists
	if schema.Description != "" {
		result += fmt.Sprintf("class %s(TypedDict, total=False):\n", schema.Name)
		result += fmt.Sprintf("    \"\"\"%s\"\"\"\n", schema.Description)
	} else {
		result += fmt.Sprintf("class %s(TypedDict, total=False):\n", schema.Name)
	}

	// Add properties
	if len(schema.Properties) > 0 {
		for propName, propType := range schema.Properties {
			pythonType := schemaTypeToPythonType(propType, rootTypes)
			
			// Check if property is required
			isRequired := false
			for _, req := range schema.Required {
				if req == propName {
					isRequired = true
					break
				}
			}
			
			// Add Optional wrapper if not required
			if !isRequired {
				pythonType = fmt.Sprintf("Optional[%s]", pythonType)
			}
			
			// Add property with type annotation
			if propType.Description != "" {
				result += fmt.Sprintf("    %s: %s  # %s\n", propName, pythonType, propType.Description)
			} else {
				result += fmt.Sprintf("    %s: %s\n", propName, pythonType)
			}
		}
	} else {
		// Empty TypedDict needs a pass
		result += "    pass\n"
	}
	
	return result + "\n"
}

// jsonTypeToGoPythonType converts a JSON schema type to a Python type
func jsonTypeToGoPythonType(typeInfo interface{}) string {
	// This is now a simplified version that returns basic types
	// The detailed type generation is handled by SchemaType and generatePythonTypedDict
	
	// Handle simple string type
	if typeStr, ok := typeInfo.(string); ok {
		switch typeStr {
		case "string":
			return "str"
		case "integer", "number":
			return "int"
		case "boolean":
			return "bool"
		case "array":
			return "List[Any]"
		case "object", "map":
			return "Dict[str, Any]"
		default:
			return "Any"
		}
	}

	// Handle complex type (object with properties)
	if typeObj, ok := typeInfo.(map[string]interface{}); ok {
		// Check for direct type property
		if typeType, ok := typeObj["type"].(string); ok {
			switch typeType {
			case "string":
				return "str"
			case "integer", "number":
				return "int"
			case "boolean":
				return "bool"
			case "array":
				return "List[Any]"
			case "object":
				return "Dict[str, Any]"
			}
		}

		// Check for schema reference
		if ref, ok := typeObj["$ref"].(string); ok {
			// Reference to another schema definition
			parts := strings.Split(ref, "/")
			if len(parts) > 0 {
				typeName := parts[len(parts)-1]
				return sanitizeName(typeName)
			}
		}

		// If we have a oneOf, use Any for now
		if _, ok := typeObj["oneOf"].([]interface{}); ok {
			return "Any"
		}
	}

	// Default to Any for complex or unknown types
	return "Any"
}

// parseOperations scans the directory structure and returns operations
func parseOperations(srcDir string, integrationName string) ([]Operation, error) {
	var operations []Operation

	// Find the flows directory
	flowsDir := filepath.Join(srcDir, "flows")
	if _, err := os.Stat(flowsDir); os.IsNotExist(err) {
		return nil, fmt.Errorf("flows directory not found in %s", srcDir)
	}

	// Find the integration directory (e.g., AWS)
	integrationDir := filepath.Join(flowsDir, integrationName)
	if _, err := os.Stat(integrationDir); os.IsNotExist(err) {
		return nil, fmt.Errorf("integration directory %s not found in flows", integrationName)
	}

	// Walk through the directory structure
	err := filepath.Walk(integrationDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip directories
		if info.IsDir() {
			return nil
		}

		// Only process JSON files
		if !strings.HasSuffix(strings.ToLower(info.Name()), ".json") {
			return nil
		}

		// Get the relative path from the integration directory
		relPath, err := filepath.Rel(integrationDir, path)
		if err != nil {
			return err
		}

		// Convert file path to module path
		// e.g., "ec2/DescribeIdFormat.json" -> "ec2"
		dir := filepath.Dir(relPath)
		if dir == "." {
			dir = ""
		}

		// Don't include the integration name in the module path
		// to avoid creating AWS.AWS.ec2 type paths
		modulePath := ""
		if dir != "" {
			modulePath = strings.ReplaceAll(dir, string(filepath.Separator), ".")
			modulePath = strings.ReplaceAll(modulePath, " ", "_")
		}

		// Read and parse the flow file
		fileContent, err := os.ReadFile(path)
		if err != nil {
			return fmt.Errorf("error reading file %s: %v", path, err)
		}

		var flowFile FlowFile
		if err := json.Unmarshal(fileContent, &flowFile); err != nil {
			return fmt.Errorf("error parsing JSON from %s: %v", path, err)
		}

		// Check if there's more than one process
		if len(flowFile.Processes) != 1 {
			return fmt.Errorf("file %s has %d processes, expected exactly 1", path, len(flowFile.Processes))
		}

		process := flowFile.Processes[0]

		// Get operation name from the flow name
		opName := sanitizeName(flowFile.Name)

		// Create operation
		op := Operation{
			Name:        opName,
			Parameters:  []Parameter{},
			ReturnType:  "None", // Default return type
			Description: flowFile.Meta.Info,
			ModulePath:  modulePath,
			FilePath:    path,
		}

		// Process variables
		for _, variable := range process.Variables {
			// Process input parameters
			if variable.IsInput {
				param := Parameter{
					Name:        sanitizeName(variable.Name),
					Type:        jsonTypeToGoPythonType(variable.Type),
					Required:    variable.Required,
					Description: variable.Meta.Description,
				}
				op.Parameters = append(op.Parameters, param)
			}

			// Process output (return type)
			if variable.IsOutput {
				op.ReturnType = jsonTypeToGoPythonType(variable.Type)
				// We could store more info about return type here if needed
			}
		}

		operations = append(operations, op)
		return nil
	})

	if err != nil {
		return nil, err
	}

	return operations, nil
}

// generatePythonStub creates a Python stub file for an operation
func generatePythonStub(op Operation, outPath string) error {
	// Add standard imports
	imports := "from typing import Any, Dict, List, Optional, Union\n"
	
	// Import specific types from _types package if needed
	typesToImport := make(map[string]bool)
	
	// Check parameter types
	for _, param := range op.Parameters {
		if strings.HasPrefix(param.Type, "Dict") || strings.HasPrefix(param.Type, "List") {
			// Add type import
			typeName := fmt.Sprintf("%s_%s_Type", op.Name, param.Name)
			typesToImport[typeName] = true
		}
	}
	
	// Check return type
	if strings.HasPrefix(op.ReturnType, "Dict") || strings.HasPrefix(op.ReturnType, "List") {
		// Add result type import
		typeName := fmt.Sprintf("%s_Result_Type", op.Name)
		typesToImport[typeName] = true
	}
	
	// If we have types to import, add the import statement
	if len(typesToImport) > 0 {
		// Create import path based on module path
		importPath := ""
		if op.ModulePath == "" {
			importPath = "_types"
		} else {
			importPath = fmt.Sprintf("_types.%s", op.ModulePath)
		}
		
		// Add import for operation-specific types
		imports += fmt.Sprintf("from %s.%s_types import *\n", importPath, op.Name)
	}
	
	imports += "\n"

	// Create docstring with description and parameters
	docstring := fmt.Sprintf("\"\"\"%s\n", op.Description)
	if len(op.Parameters) > 0 {
		docstring += "\nParameters:\n"
		for _, param := range op.Parameters {
			reqText := ""
			if param.Required {
				reqText = " (required)"
			}
			docstring += fmt.Sprintf("    %s: %s%s\n", param.Name, param.Description, reqText)
		}
	}
	docstring += fmt.Sprintf("\nReturns:\n    %s\n", op.ReturnType)
	docstring += "\"\"\""

	// Create function signature with type annotations
	signature := fmt.Sprintf("def %s(", op.Name)

	// Add parameters with type annotations
	for i, param := range op.Parameters {
		if i > 0 {
			signature += ", "
		}
		// Add type annotation
		if param.Required {
			signature += fmt.Sprintf("%s: %s", param.Name, param.Type)
		} else {
			// For optional parameters, wrap in Optional[]
			signature += fmt.Sprintf("%s: Optional[%s] = None", param.Name, param.Type)
		}
	}
	// Add return type annotation
	signature += fmt.Sprintf(") -> %s:", op.ReturnType)

	// Create function body
	funcBody := fmt.Sprintf("%s\n\n%s\n    # Generated from %s\n\n", imports, signature, op.FilePath)
	funcBody += fmt.Sprintf("    %s\n\n", docstring)

	// Add placeholder implementation
	funcBody += fmt.Sprintf("    print(\"Function %s called\")\n", op.Name)

	// Add return statement based on return type
	if op.ReturnType == "None" {
		funcBody += "    return None\n"
	} else if strings.HasPrefix(op.ReturnType, "Dict") {
		funcBody += "    return {}  # Replace with actual implementation\n"
	} else if strings.HasPrefix(op.ReturnType, "List") {
		funcBody += "    return []  # Replace with actual implementation\n"
	} else if op.ReturnType == "str" {
		funcBody += "    return \"\"  # Replace with actual implementation\n"
	} else if op.ReturnType == "int" {
		funcBody += "    return 0  # Replace with actual implementation\n"
	} else if op.ReturnType == "bool" {
		funcBody += "    return False  # Replace with actual implementation\n"
	} else {
		funcBody += "    return None  # Replace with actual implementation\n"
	}

	// Ensure directory exists
	dir := filepath.Dir(outPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %v", dir, err)
	}

	// Write to file
	if err := os.WriteFile(outPath, []byte(funcBody), 0644); err != nil {
		return fmt.Errorf("failed to write file %s: %v", outPath, err)
	}

	return nil
}

// createInitFile creates __init__.py files in all parent directories
func createInitFile(dirPath string) error {
	// Create __init__.py file
	initPath := filepath.Join(dirPath, "__init__.py")

	// Check if file already exists
	if _, err := os.Stat(initPath); os.IsNotExist(err) {
		// Create empty __init__.py file
		if err := os.WriteFile(initPath, []byte("# Generated by LowCodeFusion\n"), 0644); err != nil {
			return fmt.Errorf("failed to create __init__.py in %s: %v", dirPath, err)
		}
	}

	return nil
}

// analyzeComplexTypes examines operation parameters and return types to identify complex types
func analyzeComplexTypes(ops []Operation, registry *TypeRegistry) error {
	for _, op := range ops {
		// Check for complex parameter types
		for _, param := range op.Parameters {
			// Only register Dict and List types that have specific formats
			if strings.HasPrefix(param.Type, "Dict") || strings.HasPrefix(param.Type, "List") {
				// Register this as a potential complex type
				typeName := fmt.Sprintf("%s_%s_Type", op.Name, param.Name)
				registry.RegisterType(
					typeName,
					param.Type,
					fmt.Sprintf("Type definition for parameter %s in %s", param.Name, op.Name),
					op.FilePath,
					op.ModulePath,
					op.Name, // Pass operation name
				)
			}
		}

		// Check for complex return type
		if strings.HasPrefix(op.ReturnType, "Dict") || strings.HasPrefix(op.ReturnType, "List") {
			// Register this as a potential complex type
			typeName := fmt.Sprintf("%s_Result_Type", op.Name)
			registry.RegisterType(
				typeName,
				op.ReturnType,
				fmt.Sprintf("Type definition for return value of %s", op.Name),
				op.FilePath,
				op.ModulePath,
				op.Name, // Pass operation name
			)
		}
	}

	return nil
}

// GenerateStubs scaffolds Python modules for the integration
func GenerateStubs(def *fetcher.IntegrationDef, srcDir, outDir string) error {
	// Parse operations from directory structure
	ops, err := parseOperations(srcDir, def.Name)
	if err != nil {
		return err
	}

	// Create a type registry
	typeRegistry := NewTypeRegistry(outDir)

	// Analyze operations for complex types
	if err := analyzeComplexTypes(ops, typeRegistry); err != nil {
		return err
	}

	// Generate type definitions
	if err := typeRegistry.WriteTypesFiles(outDir); err != nil {
		return err
	}

	// Print the paths as they would appear in the final Python library
	fmt.Println("Generating Python stubs:")
	moduleMap := make(map[string]bool)

	for _, op := range ops {
		modulePath := op.ModulePath
		if !moduleMap[modulePath] {
			moduleMap[modulePath] = true
			fmt.Printf("- Module: %s\n", modulePath)
		}

		// Convert module path to directory structure
		// AWS.ec2 -> AWS/ec2
		moduleDirPath := strings.ReplaceAll(modulePath, ".", string(filepath.Separator))

		// Create full path for the output file
		opDirPath := filepath.Join(outDir, moduleDirPath)
		opFilePath := filepath.Join(opDirPath, fmt.Sprintf("%s.py", op.Name))

		// Create __init__.py files in all parent directories
		dirPath := outDir
		for _, part := range strings.Split(moduleDirPath, string(filepath.Separator)) {
			dirPath = filepath.Join(dirPath, part)
			if err := os.MkdirAll(dirPath, 0755); err != nil {
				return fmt.Errorf("failed to create directory %s: %v", dirPath, err)
			}
			if err := createInitFile(dirPath); err != nil {
				return err
			}
		}

		// Generate Python stub file
		if err := generatePythonStub(op, opFilePath); err != nil {
			return err
		}

		fmt.Printf("  - Generated: %s\n", opFilePath)
	}

	fmt.Printf("\nSuccessfully generated %d Python stub files\n", len(ops))
	return nil
}
